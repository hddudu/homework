package com.hongdu.gupao.derector;

/**
 * @ClassName DecorationIntroduction
 * @Description  装饰者模式介绍
 *  一个被装饰的本地对象
 *  一个装饰抽象类
 *      然后是一系列的装饰角色继承了装饰抽象类
 *
 *      然后是 : 装饰类里面持有原装对象的引用从而为原装对象增加色彩!
 *
 *      问题:  说装饰者模式比用继承会更富有弹性,在类图中不是一样用到了继承了吗? 
 *
 *     说明:装饰者和被装饰者之间必须是一样的类型,也就是要有共同的超类。在这里应用继承并不是实现方法的复制,而是实现类型的匹配。因为装饰者和被装饰者是同一个类型,因此装饰者可以取代被装饰者,这样就使被装饰者拥有了装饰者独有的行为。根据装饰者模式的理念,我们可以在任何时候,实现新的装饰者增加新的行为。如果是用继承,每当需要增加新的行为时,就要修改原程序了。
 * ---------------------
 * 作者：renxing521
 * 来源：CSDN
 * 原文：https://blog.csdn.net/renxing521/article/details/81004266
 * 版权声明：本文为博主原创文章，转载请附上博文链接！
 *
 *   继承父接口,又持有父接口的引用,那么该类就拥有父接口的子类的属性, 因为可以通过指向,从而实例化对应的子类;
 *
 *   每一个继承父接口的类都是这样,那么可以无限扩展
 *
 * @Author dudu
 * @Date 2019/6/28 18:21
 * @Version 1.0
 */
public class DecorationIntroduction {
}
